// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;


use flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod kneaf {

  use core::mem;
  use core::cmp::Ordering;

  
  use flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod block {

  use core::mem;
  use core::cmp::Ordering;

  
  use flatbuffers::{EndianScalar, Follow};

pub enum BlockEntityDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockEntityData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockEntityData<'a> {
  type Inner = BlockEntityData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BlockEntityData<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_BLOCK_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_DISTANCE: flatbuffers::VOffsetT = 8;
  pub const VT_X: flatbuffers::VOffsetT = 10;
  pub const VT_Y: flatbuffers::VOffsetT = 12;
  pub const VT_Z: flatbuffers::VOffsetT = 14;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockEntityData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockEntityDataArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockEntityData<'bldr>> {
    let mut builder = BlockEntityDataBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_z(args.z);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.add_distance(args.distance);
    if let Some(x) = args.block_type { builder.add_block_type(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    unsafe { self._tab.get::<u64>(BlockEntityData::VT_ID, Some(0)).unwrap() }
  }
  #[inline]
  pub fn block_type(&self) -> Option<&'a str> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BlockEntityData::VT_BLOCK_TYPE, None) }
  }
  #[inline]
  pub fn distance(&self) -> f32 {
    unsafe { self._tab.get::<f32>(BlockEntityData::VT_DISTANCE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn x(&self) -> i32 {
    unsafe { self._tab.get::<i32>(BlockEntityData::VT_X, Some(0)).unwrap() }
  }
  #[inline]
  pub fn y(&self) -> i32 {
    unsafe { self._tab.get::<i32>(BlockEntityData::VT_Y, Some(0)).unwrap() }
  }
  #[inline]
  pub fn z(&self) -> i32 {
    unsafe { self._tab.get::<i32>(BlockEntityData::VT_Z, Some(0)).unwrap() }
  }
}

impl flatbuffers::Verifiable for BlockEntityData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("block_type", Self::VT_BLOCK_TYPE, false)?
     .visit_field::<f32>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<i32>("x", Self::VT_X, false)?
     .visit_field::<i32>("y", Self::VT_Y, false)?
     .visit_field::<i32>("z", Self::VT_Z, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockEntityDataArgs<'a> {
    pub id: u64,
    pub block_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub distance: f32,
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
impl<'a> Default for BlockEntityDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockEntityDataArgs {
      id: 0,
      block_type: None,
      distance: 0.0,
      x: 0,
      y: 0,
      z: 0,
    }
  }
}

pub struct BlockEntityDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockEntityDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(BlockEntityData::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_block_type(&mut self, block_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockEntityData::VT_BLOCK_TYPE, block_type);
  }
  #[inline]
  pub fn add_distance(&mut self, distance: f32) {
    self.fbb_.push_slot::<f32>(BlockEntityData::VT_DISTANCE, distance, 0.0);
  }
  #[inline]
  pub fn add_x(&mut self, x: i32) {
    self.fbb_.push_slot::<i32>(BlockEntityData::VT_X, x, 0);
  }
  #[inline]
  pub fn add_y(&mut self, y: i32) {
    self.fbb_.push_slot::<i32>(BlockEntityData::VT_Y, y, 0);
  }
  #[inline]
  pub fn add_z(&mut self, z: i32) {
    self.fbb_.push_slot::<i32>(BlockEntityData::VT_Z, z, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockEntityDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockEntityDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockEntityData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockEntityData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockEntityData");
      ds.field("id", &self.id());
      ds.field("block_type", &self.block_type());
      ds.field("distance", &self.distance());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.finish()
  }
}
pub enum BlockInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockInput<'a> {
  type Inner = BlockInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BlockInput<'a> {
  pub const VT_TICK_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_BLOCK_ENTITIES: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockInputArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockInput<'bldr>> {
    let mut builder = BlockInputBuilder::new(_fbb);
    builder.add_tick_count(args.tick_count);
    if let Some(x) = args.block_entities { builder.add_block_entities(x); }
    builder.finish()
  }


  #[inline]
  pub fn tick_count(&self) -> u64 {
    unsafe { self._tab.get::<u64>(BlockInput::VT_TICK_COUNT, Some(0)).unwrap() }
  }
  #[inline]
  pub fn block_entities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockEntityData<'a>>>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockEntityData>>>>(BlockInput::VT_BLOCK_ENTITIES, None) }
  }
}

impl flatbuffers::Verifiable for BlockInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("tick_count", Self::VT_TICK_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<BlockEntityData>>>>("block_entities", Self::VT_BLOCK_ENTITIES, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockInputArgs<'a> {
    pub tick_count: u64,
    pub block_entities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<BlockEntityData<'a>>>>>,
}
impl<'a> Default for BlockInputArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockInputArgs {
      tick_count: 0,
      block_entities: None,
    }
  }
}

pub struct BlockInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_tick_count(&mut self, tick_count: u64) {
    self.fbb_.push_slot::<u64>(BlockInput::VT_TICK_COUNT, tick_count, 0);
  }
  #[inline]
  pub fn add_block_entities(&mut self, block_entities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<BlockEntityData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockInput::VT_BLOCK_ENTITIES, block_entities);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockInput");
      ds.field("tick_count", &self.tick_count());
      ds.field("block_entities", &self.block_entities());
      ds.finish()
  }
}
pub enum BlockProcessResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockProcessResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockProcessResult<'a> {
  type Inner = BlockProcessResult<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BlockProcessResult<'a> {
  pub const VT_BLOCK_ENTITIES_TO_TICK: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockProcessResult { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockProcessResultArgs<'args>
  ) -> flatbuffers::WIPOffset<BlockProcessResult<'bldr>> {
    let mut builder = BlockProcessResultBuilder::new(_fbb);
    if let Some(x) = args.block_entities_to_tick { builder.add_block_entities_to_tick(x); }
    builder.finish()
  }


  #[inline]
  pub fn block_entities_to_tick(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(BlockProcessResult::VT_BLOCK_ENTITIES_TO_TICK, None) }
  }
}

impl flatbuffers::Verifiable for BlockProcessResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("block_entities_to_tick", Self::VT_BLOCK_ENTITIES_TO_TICK, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockProcessResultArgs<'a> {
    pub block_entities_to_tick: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for BlockProcessResultArgs<'a> {
  #[inline]
  fn default() -> Self {
    BlockProcessResultArgs {
      block_entities_to_tick: None,
    }
  }
}

pub struct BlockProcessResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockProcessResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_block_entities_to_tick(&mut self, block_entities_to_tick: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BlockProcessResult::VT_BLOCK_ENTITIES_TO_TICK, block_entities_to_tick);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockProcessResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockProcessResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockProcessResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockProcessResult<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockProcessResult");
      ds.field("block_entities_to_tick", &self.block_entities_to_tick());
      ds.finish()
  }
}
pub enum BlockConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct BlockConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BlockConfig<'a> {
  type Inner = BlockConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> BlockConfig<'a> {
  pub const VT_CLOSE_RADIUS: flatbuffers::VOffsetT = 4;
  pub const VT_MEDIUM_RADIUS: flatbuffers::VOffsetT = 6;
  pub const VT_CLOSE_RATE: flatbuffers::VOffsetT = 8;
  pub const VT_MEDIUM_RATE: flatbuffers::VOffsetT = 10;
  pub const VT_FAR_RATE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    BlockConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args BlockConfigArgs
  ) -> flatbuffers::WIPOffset<BlockConfig<'bldr>> {
    let mut builder = BlockConfigBuilder::new(_fbb);
    builder.add_far_rate(args.far_rate);
    builder.add_medium_rate(args.medium_rate);
    builder.add_close_rate(args.close_rate);
    builder.add_medium_radius(args.medium_radius);
    builder.add_close_radius(args.close_radius);
    builder.finish()
  }


  #[inline]
  pub fn close_radius(&self) -> f32 {
    unsafe { self._tab.get::<f32>(BlockConfig::VT_CLOSE_RADIUS, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn medium_radius(&self) -> f32 {
    unsafe { self._tab.get::<f32>(BlockConfig::VT_MEDIUM_RADIUS, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn close_rate(&self) -> f32 {
    unsafe { self._tab.get::<f32>(BlockConfig::VT_CLOSE_RATE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn medium_rate(&self) -> f32 {
    unsafe { self._tab.get::<f32>(BlockConfig::VT_MEDIUM_RATE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn far_rate(&self) -> f32 {
    unsafe { self._tab.get::<f32>(BlockConfig::VT_FAR_RATE, Some(0.0)).unwrap() }
  }
}

impl flatbuffers::Verifiable for BlockConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("close_radius", Self::VT_CLOSE_RADIUS, false)?
     .visit_field::<f32>("medium_radius", Self::VT_MEDIUM_RADIUS, false)?
     .visit_field::<f32>("close_rate", Self::VT_CLOSE_RATE, false)?
     .visit_field::<f32>("medium_rate", Self::VT_MEDIUM_RATE, false)?
     .visit_field::<f32>("far_rate", Self::VT_FAR_RATE, false)?
     .finish();
    Ok(())
  }
}
pub struct BlockConfigArgs {
    pub close_radius: f32,
    pub medium_radius: f32,
    pub close_rate: f32,
    pub medium_rate: f32,
    pub far_rate: f32,
}
impl<'a> Default for BlockConfigArgs {
  #[inline]
  fn default() -> Self {
    BlockConfigArgs {
      close_radius: 0.0,
      medium_radius: 0.0,
      close_rate: 0.0,
      medium_rate: 0.0,
      far_rate: 0.0,
    }
  }
}

pub struct BlockConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BlockConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_close_radius(&mut self, close_radius: f32) {
    self.fbb_.push_slot::<f32>(BlockConfig::VT_CLOSE_RADIUS, close_radius, 0.0);
  }
  #[inline]
  pub fn add_medium_radius(&mut self, medium_radius: f32) {
    self.fbb_.push_slot::<f32>(BlockConfig::VT_MEDIUM_RADIUS, medium_radius, 0.0);
  }
  #[inline]
  pub fn add_close_rate(&mut self, close_rate: f32) {
    self.fbb_.push_slot::<f32>(BlockConfig::VT_CLOSE_RATE, close_rate, 0.0);
  }
  #[inline]
  pub fn add_medium_rate(&mut self, medium_rate: f32) {
    self.fbb_.push_slot::<f32>(BlockConfig::VT_MEDIUM_RATE, medium_rate, 0.0);
  }
  #[inline]
  pub fn add_far_rate(&mut self, far_rate: f32) {
    self.fbb_.push_slot::<f32>(BlockConfig::VT_FAR_RATE, far_rate, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BlockConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BlockConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BlockConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for BlockConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("BlockConfig");
      ds.field("close_radius", &self.close_radius());
      ds.field("medium_radius", &self.medium_radius());
      ds.field("close_rate", &self.close_rate());
      ds.field("medium_rate", &self.medium_rate());
      ds.field("far_rate", &self.far_rate());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_block_input<'a>(buf: &'a [u8]) -> BlockInput<'a> {
  unsafe { flatbuffers::root_unchecked::<BlockInput<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_block_input<'a>(buf: &'a [u8]) -> BlockInput<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<BlockInput<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `BlockInput`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_block_input_unchecked`.
pub fn root_as_block_input(buf: &[u8]) -> Result<BlockInput, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<BlockInput>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `BlockInput` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_block_input_unchecked`.
pub fn size_prefixed_root_as_block_input(buf: &[u8]) -> Result<BlockInput, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<BlockInput>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `BlockInput` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_block_input_unchecked`.
pub fn root_as_block_input_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BlockInput<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<BlockInput<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `BlockInput` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_block_input_unchecked`.
pub fn size_prefixed_root_as_block_input_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<BlockInput<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<BlockInput<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a BlockInput and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `BlockInput`.
pub unsafe fn root_as_block_input_unchecked(buf: &[u8]) -> BlockInput {
  flatbuffers::root_unchecked::<BlockInput>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed BlockInput and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `BlockInput`.
pub unsafe fn size_prefixed_root_as_block_input_unchecked(buf: &[u8]) -> BlockInput {
  flatbuffers::size_prefixed_root_unchecked::<BlockInput>(buf)
}
#[inline]
pub fn finish_block_input_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<BlockInput<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_block_input_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<BlockInput<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod block
}  // pub mod kneaf
