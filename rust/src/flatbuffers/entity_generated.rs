// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;


use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod kneaf {

  use core::mem;
  use core::cmp::Ordering;

  
  use self::flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod entity {

  use core::mem;
  use core::cmp::Ordering;

  
  use self::flatbuffers::{EndianScalar, Follow};

pub enum EntityDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EntityData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntityData<'a> {
  type Inner = EntityData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntityData<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITY_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_X: flatbuffers::VOffsetT = 8;
  pub const VT_Y: flatbuffers::VOffsetT = 10;
  pub const VT_Z: flatbuffers::VOffsetT = 12;
  pub const VT_DISTANCE: flatbuffers::VOffsetT = 14;
  pub const VT_IS_BLOCK_ENTITY: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntityData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EntityDataArgs<'args>
  ) -> flatbuffers::WIPOffset<EntityData<'bldr>> {
    let mut builder = EntityDataBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_distance(args.distance);
    builder.add_z(args.z);
    builder.add_y(args.y);
    builder.add_x(args.x);
    if let Some(x) = args.entity_type { builder.add_entity_type(x); }
    builder.add_is_block_entity(args.is_block_entity);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    unsafe { self._tab.get::<u64>(EntityData::VT_ID, Some(0)).unwrap() }
  }
  #[inline]
  pub fn entity_type(&self) -> Option<&'a str> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(EntityData::VT_ENTITY_TYPE, None) }
  }
  #[inline]
  pub fn x(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityData::VT_X, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn y(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityData::VT_Y, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn z(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityData::VT_Z, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn distance(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityData::VT_DISTANCE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn is_block_entity(&self) -> bool {
    unsafe { self._tab.get::<bool>(EntityData::VT_IS_BLOCK_ENTITY, Some(false)).unwrap() }
  }
}

impl flatbuffers::Verifiable for EntityData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entity_type", Self::VT_ENTITY_TYPE, false)?
     .visit_field::<f32>("x", Self::VT_X, false)?
     .visit_field::<f32>("y", Self::VT_Y, false)?
     .visit_field::<f32>("z", Self::VT_Z, false)?
     .visit_field::<f32>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<bool>("is_block_entity", Self::VT_IS_BLOCK_ENTITY, false)?
     .finish();
    Ok(())
  }
}
pub struct EntityDataArgs<'a> {
    pub id: u64,
    pub entity_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub distance: f32,
    pub is_block_entity: bool,
}
impl<'a> Default for EntityDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntityDataArgs {
      id: 0,
      entity_type: None,
      x: 0.0,
      y: 0.0,
      z: 0.0,
      distance: 0.0,
      is_block_entity: false,
    }
  }
}

pub struct EntityDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EntityDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(EntityData::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_entity_type(&mut self, entity_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntityData::VT_ENTITY_TYPE, entity_type);
  }
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(EntityData::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(EntityData::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_z(&mut self, z: f32) {
    self.fbb_.push_slot::<f32>(EntityData::VT_Z, z, 0.0);
  }
  #[inline]
  pub fn add_distance(&mut self, distance: f32) {
    self.fbb_.push_slot::<f32>(EntityData::VT_DISTANCE, distance, 0.0);
  }
  #[inline]
  pub fn add_is_block_entity(&mut self, is_block_entity: bool) {
    self.fbb_.push_slot::<bool>(EntityData::VT_IS_BLOCK_ENTITY, is_block_entity, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntityDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EntityDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntityData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntityData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntityData");
      ds.field("id", &self.id());
      ds.field("entity_type", &self.entity_type());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.field("distance", &self.distance());
      ds.field("is_block_entity", &self.is_block_entity());
      ds.finish()
  }
}
pub enum PlayerDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PlayerData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PlayerData<'a> {
  type Inner = PlayerData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> PlayerData<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_X: flatbuffers::VOffsetT = 6;
  pub const VT_Y: flatbuffers::VOffsetT = 8;
  pub const VT_Z: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PlayerData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args PlayerDataArgs
  ) -> flatbuffers::WIPOffset<PlayerData<'bldr>> {
    let mut builder = PlayerDataBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_z(args.z);
    builder.add_y(args.y);
    builder.add_x(args.x);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    unsafe { self._tab.get::<u64>(PlayerData::VT_ID, Some(0)).unwrap() }
  }
  #[inline]
  pub fn x(&self) -> f32 {
    unsafe { self._tab.get::<f32>(PlayerData::VT_X, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn y(&self) -> f32 {
    unsafe { self._tab.get::<f32>(PlayerData::VT_Y, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn z(&self) -> f32 {
    unsafe { self._tab.get::<f32>(PlayerData::VT_Z, Some(0.0)).unwrap() }
  }
}

impl flatbuffers::Verifiable for PlayerData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<f32>("x", Self::VT_X, false)?
     .visit_field::<f32>("y", Self::VT_Y, false)?
     .visit_field::<f32>("z", Self::VT_Z, false)?
     .finish();
    Ok(())
  }
}
pub struct PlayerDataArgs {
    pub id: u64,
    pub x: f32,
    pub y: f32,
    pub z: f32,
}
impl<'a> Default for PlayerDataArgs {
  #[inline]
  fn default() -> Self {
    PlayerDataArgs {
      id: 0,
      x: 0.0,
      y: 0.0,
      z: 0.0,
    }
  }
}

pub struct PlayerDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PlayerDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(PlayerData::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_x(&mut self, x: f32) {
    self.fbb_.push_slot::<f32>(PlayerData::VT_X, x, 0.0);
  }
  #[inline]
  pub fn add_y(&mut self, y: f32) {
    self.fbb_.push_slot::<f32>(PlayerData::VT_Y, y, 0.0);
  }
  #[inline]
  pub fn add_z(&mut self, z: f32) {
    self.fbb_.push_slot::<f32>(PlayerData::VT_Z, z, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PlayerDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    PlayerDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PlayerData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PlayerData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PlayerData");
      ds.field("id", &self.id());
      ds.field("x", &self.x());
      ds.field("y", &self.y());
      ds.field("z", &self.z());
      ds.finish()
  }
}
pub enum EntityConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EntityConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntityConfig<'a> {
  type Inner = EntityConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntityConfig<'a> {
  pub const VT_CLOSE_RADIUS: flatbuffers::VOffsetT = 4;
  pub const VT_MEDIUM_RADIUS: flatbuffers::VOffsetT = 6;
  pub const VT_CLOSE_RATE: flatbuffers::VOffsetT = 8;
  pub const VT_MEDIUM_RATE: flatbuffers::VOffsetT = 10;
  pub const VT_FAR_RATE: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntityConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EntityConfigArgs
  ) -> flatbuffers::WIPOffset<EntityConfig<'bldr>> {
    let mut builder = EntityConfigBuilder::new(_fbb);
    builder.add_far_rate(args.far_rate);
    builder.add_medium_rate(args.medium_rate);
    builder.add_close_rate(args.close_rate);
    builder.add_medium_radius(args.medium_radius);
    builder.add_close_radius(args.close_radius);
    builder.finish()
  }


  #[inline]
  pub fn close_radius(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityConfig::VT_CLOSE_RADIUS, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn medium_radius(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityConfig::VT_MEDIUM_RADIUS, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn close_rate(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityConfig::VT_CLOSE_RATE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn medium_rate(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityConfig::VT_MEDIUM_RATE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn far_rate(&self) -> f32 {
    unsafe { self._tab.get::<f32>(EntityConfig::VT_FAR_RATE, Some(0.0)).unwrap() }
  }
}

impl flatbuffers::Verifiable for EntityConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("close_radius", Self::VT_CLOSE_RADIUS, false)?
     .visit_field::<f32>("medium_radius", Self::VT_MEDIUM_RADIUS, false)?
     .visit_field::<f32>("close_rate", Self::VT_CLOSE_RATE, false)?
     .visit_field::<f32>("medium_rate", Self::VT_MEDIUM_RATE, false)?
     .visit_field::<f32>("far_rate", Self::VT_FAR_RATE, false)?
     .finish();
    Ok(())
  }
}
pub struct EntityConfigArgs {
    pub close_radius: f32,
    pub medium_radius: f32,
    pub close_rate: f32,
    pub medium_rate: f32,
    pub far_rate: f32,
}
impl<'a> Default for EntityConfigArgs {
  #[inline]
  fn default() -> Self {
    EntityConfigArgs {
      close_radius: 0.0,
      medium_radius: 0.0,
      close_rate: 0.0,
      medium_rate: 0.0,
      far_rate: 0.0,
    }
  }
}

pub struct EntityConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EntityConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_close_radius(&mut self, close_radius: f32) {
    self.fbb_.push_slot::<f32>(EntityConfig::VT_CLOSE_RADIUS, close_radius, 0.0);
  }
  #[inline]
  pub fn add_medium_radius(&mut self, medium_radius: f32) {
    self.fbb_.push_slot::<f32>(EntityConfig::VT_MEDIUM_RADIUS, medium_radius, 0.0);
  }
  #[inline]
  pub fn add_close_rate(&mut self, close_rate: f32) {
    self.fbb_.push_slot::<f32>(EntityConfig::VT_CLOSE_RATE, close_rate, 0.0);
  }
  #[inline]
  pub fn add_medium_rate(&mut self, medium_rate: f32) {
    self.fbb_.push_slot::<f32>(EntityConfig::VT_MEDIUM_RATE, medium_rate, 0.0);
  }
  #[inline]
  pub fn add_far_rate(&mut self, far_rate: f32) {
    self.fbb_.push_slot::<f32>(EntityConfig::VT_FAR_RATE, far_rate, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntityConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EntityConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntityConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntityConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntityConfig");
      ds.field("close_radius", &self.close_radius());
      ds.field("medium_radius", &self.medium_radius());
      ds.field("close_rate", &self.close_rate());
      ds.field("medium_rate", &self.medium_rate());
      ds.field("far_rate", &self.far_rate());
      ds.finish()
  }
}
pub enum EntityInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EntityInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntityInput<'a> {
  type Inner = EntityInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntityInput<'a> {
  pub const VT_TICK_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITIES: flatbuffers::VOffsetT = 6;
  pub const VT_PLAYERS: flatbuffers::VOffsetT = 8;
  pub const VT_ENTITY_CONFIG: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntityInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EntityInputArgs<'args>
  ) -> flatbuffers::WIPOffset<EntityInput<'bldr>> {
    let mut builder = EntityInputBuilder::new(_fbb);
    builder.add_tick_count(args.tick_count);
    if let Some(x) = args.entity_config { builder.add_entity_config(x); }
    if let Some(x) = args.players { builder.add_players(x); }
    if let Some(x) = args.entities { builder.add_entities(x); }
    builder.finish()
  }


  #[inline]
  pub fn tick_count(&self) -> u64 {
    unsafe { self._tab.get::<u64>(EntityInput::VT_TICK_COUNT, Some(0)).unwrap() }
  }
  #[inline]
  pub fn entities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntityData<'a>>>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntityData>>>>(EntityInput::VT_ENTITIES, None) }
  }
  #[inline]
  pub fn players(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerData<'a>>>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerData>>>>(EntityInput::VT_PLAYERS, None) }
  }
  #[inline]
  pub fn entity_config(&self) -> Option<EntityConfig<'a>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<EntityConfig>>(EntityInput::VT_ENTITY_CONFIG, None) }
  }
}

impl flatbuffers::Verifiable for EntityInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("tick_count", Self::VT_TICK_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<EntityData>>>>("entities", Self::VT_ENTITIES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<PlayerData>>>>("players", Self::VT_PLAYERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<EntityConfig>>("entity_config", Self::VT_ENTITY_CONFIG, false)?
     .finish();
    Ok(())
  }
}
pub struct EntityInputArgs<'a> {
    pub tick_count: u64,
    pub entities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<EntityData<'a>>>>>,
    pub players: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<PlayerData<'a>>>>>,
    pub entity_config: Option<flatbuffers::WIPOffset<EntityConfig<'a>>>,
}
impl<'a> Default for EntityInputArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntityInputArgs {
      tick_count: 0,
      entities: None,
      players: None,
      entity_config: None,
    }
  }
}

pub struct EntityInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EntityInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_tick_count(&mut self, tick_count: u64) {
    self.fbb_.push_slot::<u64>(EntityInput::VT_TICK_COUNT, tick_count, 0);
  }
  #[inline]
  pub fn add_entities(&mut self, entities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<EntityData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntityInput::VT_ENTITIES, entities);
  }
  #[inline]
  pub fn add_players(&mut self, players: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<PlayerData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntityInput::VT_PLAYERS, players);
  }
  #[inline]
  pub fn add_entity_config(&mut self, entity_config: flatbuffers::WIPOffset<EntityConfig<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<EntityConfig>>(EntityInput::VT_ENTITY_CONFIG, entity_config);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntityInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EntityInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntityInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntityInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntityInput");
      ds.field("tick_count", &self.tick_count());
      ds.field("entities", &self.entities());
      ds.field("players", &self.players());
      ds.field("entity_config", &self.entity_config());
      ds.finish()
  }
}
pub enum EntityProcessResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct EntityProcessResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EntityProcessResult<'a> {
  type Inner = EntityProcessResult<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> EntityProcessResult<'a> {
  pub const VT_ENTITIES_TO_TICK: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    EntityProcessResult { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args EntityProcessResultArgs<'args>
  ) -> flatbuffers::WIPOffset<EntityProcessResult<'bldr>> {
    let mut builder = EntityProcessResultBuilder::new(_fbb);
    if let Some(x) = args.entities_to_tick { builder.add_entities_to_tick(x); }
    builder.finish()
  }


  #[inline]
  pub fn entities_to_tick(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(EntityProcessResult::VT_ENTITIES_TO_TICK, None) }
  }
}

impl flatbuffers::Verifiable for EntityProcessResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("entities_to_tick", Self::VT_ENTITIES_TO_TICK, false)?
     .finish();
    Ok(())
  }
}
pub struct EntityProcessResultArgs<'a> {
    pub entities_to_tick: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for EntityProcessResultArgs<'a> {
  #[inline]
  fn default() -> Self {
    EntityProcessResultArgs {
      entities_to_tick: None,
    }
  }
}

pub struct EntityProcessResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EntityProcessResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_entities_to_tick(&mut self, entities_to_tick: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EntityProcessResult::VT_ENTITIES_TO_TICK, entities_to_tick);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EntityProcessResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EntityProcessResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EntityProcessResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for EntityProcessResult<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("EntityProcessResult");
      ds.field("entities_to_tick", &self.entities_to_tick());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_entity_input<'a>(buf: &'a [u8]) -> EntityInput<'a> {
  unsafe { flatbuffers::root_unchecked::<EntityInput<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_entity_input<'a>(buf: &'a [u8]) -> EntityInput<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<EntityInput<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `EntityInput`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_input_unchecked`.
pub fn root_as_entity_input(buf: &[u8]) -> Result<EntityInput, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<EntityInput>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `EntityInput` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_entity_input_unchecked`.
pub fn size_prefixed_root_as_entity_input(buf: &[u8]) -> Result<EntityInput, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<EntityInput>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `EntityInput` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_input_unchecked`.
pub fn root_as_entity_input_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EntityInput<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<EntityInput<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `EntityInput` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_entity_input_unchecked`.
pub fn size_prefixed_root_as_entity_input_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<EntityInput<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<EntityInput<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a EntityInput and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `EntityInput`.
pub unsafe fn root_as_entity_input_unchecked(buf: &[u8]) -> EntityInput {
  flatbuffers::root_unchecked::<EntityInput>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed EntityInput and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `EntityInput`.
pub unsafe fn size_prefixed_root_as_entity_input_unchecked(buf: &[u8]) -> EntityInput {
  flatbuffers::size_prefixed_root_unchecked::<EntityInput>(buf)
}
#[inline]
pub fn finish_entity_input_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<EntityInput<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_entity_input_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<EntityInput<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod entity
}  // pub mod kneaf

