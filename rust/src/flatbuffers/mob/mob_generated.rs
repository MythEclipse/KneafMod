// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;


use flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod kneaf {

  use core::mem;
  use core::cmp::Ordering;

  
  use flatbuffers::{EndianScalar, Follow};
#[allow(unused_imports, dead_code)]
pub mod mob {

  use core::mem;
  use core::cmp::Ordering;

  
  use flatbuffers::{EndianScalar, Follow};

pub enum MobDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MobData<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MobData<'a> {
  type Inner = MobData<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MobData<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_ENTITY_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_DISTANCE: flatbuffers::VOffsetT = 8;
  pub const VT_IS_PASSIVE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MobData { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MobDataArgs<'args>
  ) -> flatbuffers::WIPOffset<MobData<'bldr>> {
    let mut builder = MobDataBuilder::new(_fbb);
    builder.add_id(args.id);
    builder.add_distance(args.distance);
    if let Some(x) = args.entity_type { builder.add_entity_type(x); }
    builder.add_is_passive(args.is_passive);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> u64 {
    unsafe { self._tab.get::<u64>(MobData::VT_ID, Some(0)).unwrap() }
  }
  #[inline]
  pub fn entity_type(&self) -> Option<&'a str> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MobData::VT_ENTITY_TYPE, None) }
  }
  #[inline]
  pub fn distance(&self) -> f32 {
    unsafe { self._tab.get::<f32>(MobData::VT_DISTANCE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn is_passive(&self) -> bool {
    unsafe { self._tab.get::<bool>(MobData::VT_IS_PASSIVE, Some(false)).unwrap() }
  }
}

impl flatbuffers::Verifiable for MobData<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("id", Self::VT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("entity_type", Self::VT_ENTITY_TYPE, false)?
     .visit_field::<f32>("distance", Self::VT_DISTANCE, false)?
     .visit_field::<bool>("is_passive", Self::VT_IS_PASSIVE, false)?
     .finish();
    Ok(())
  }
}
pub struct MobDataArgs<'a> {
    pub id: u64,
    pub entity_type: Option<flatbuffers::WIPOffset<&'a str>>,
    pub distance: f32,
    pub is_passive: bool,
}
impl<'a> Default for MobDataArgs<'a> {
  #[inline]
  fn default() -> Self {
    MobDataArgs {
      id: 0,
      entity_type: None,
      distance: 0.0,
      is_passive: false,
    }
  }
}

pub struct MobDataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MobDataBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: u64) {
    self.fbb_.push_slot::<u64>(MobData::VT_ID, id, 0);
  }
  #[inline]
  pub fn add_entity_type(&mut self, entity_type: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MobData::VT_ENTITY_TYPE, entity_type);
  }
  #[inline]
  pub fn add_distance(&mut self, distance: f32) {
    self.fbb_.push_slot::<f32>(MobData::VT_DISTANCE, distance, 0.0);
  }
  #[inline]
  pub fn add_is_passive(&mut self, is_passive: bool) {
    self.fbb_.push_slot::<bool>(MobData::VT_IS_PASSIVE, is_passive, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MobDataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MobDataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MobData<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MobData<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MobData");
      ds.field("id", &self.id());
      ds.field("entity_type", &self.entity_type());
      ds.field("distance", &self.distance());
      ds.field("is_passive", &self.is_passive());
      ds.finish()
  }
}
pub enum MobInputOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MobInput<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MobInput<'a> {
  type Inner = MobInput<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MobInput<'a> {
  pub const VT_TICK_COUNT: flatbuffers::VOffsetT = 4;
  pub const VT_MOBS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MobInput { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MobInputArgs<'args>
  ) -> flatbuffers::WIPOffset<MobInput<'bldr>> {
    let mut builder = MobInputBuilder::new(_fbb);
    builder.add_tick_count(args.tick_count);
    if let Some(x) = args.mobs { builder.add_mobs(x); }
    builder.finish()
  }


  #[inline]
  pub fn tick_count(&self) -> u64 {
    unsafe { self._tab.get::<u64>(MobInput::VT_TICK_COUNT, Some(0)).unwrap() }
  }
  #[inline]
  pub fn mobs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MobData<'a>>>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MobData>>>>(MobInput::VT_MOBS, None) }
  }
}

impl flatbuffers::Verifiable for MobInput<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("tick_count", Self::VT_TICK_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<MobData>>>>("mobs", Self::VT_MOBS, false)?
     .finish();
    Ok(())
  }
}
pub struct MobInputArgs<'a> {
    pub tick_count: u64,
    pub mobs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<MobData<'a>>>>>,
}
impl<'a> Default for MobInputArgs<'a> {
  #[inline]
  fn default() -> Self {
    MobInputArgs {
      tick_count: 0,
      mobs: None,
    }
  }
}

pub struct MobInputBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MobInputBuilder<'a, 'b> {
  #[inline]
  pub fn add_tick_count(&mut self, tick_count: u64) {
    self.fbb_.push_slot::<u64>(MobInput::VT_TICK_COUNT, tick_count, 0);
  }
  #[inline]
  pub fn add_mobs(&mut self, mobs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<MobData<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MobInput::VT_MOBS, mobs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MobInputBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MobInputBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MobInput<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MobInput<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MobInput");
      ds.field("tick_count", &self.tick_count());
      ds.field("mobs", &self.mobs());
      ds.finish()
  }
}
pub enum MobProcessResultOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MobProcessResult<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MobProcessResult<'a> {
  type Inner = MobProcessResult<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MobProcessResult<'a> {
  pub const VT_MOBS_TO_DISABLE_AI: flatbuffers::VOffsetT = 4;
  pub const VT_MOBS_TO_SIMPLIFY_AI: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MobProcessResult { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MobProcessResultArgs<'args>
  ) -> flatbuffers::WIPOffset<MobProcessResult<'bldr>> {
    let mut builder = MobProcessResultBuilder::new(_fbb);
    if let Some(x) = args.mobs_to_simplify_ai { builder.add_mobs_to_simplify_ai(x); }
    if let Some(x) = args.mobs_to_disable_ai { builder.add_mobs_to_disable_ai(x); }
    builder.finish()
  }


  #[inline]
  pub fn mobs_to_disable_ai(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(MobProcessResult::VT_MOBS_TO_DISABLE_AI, None) }
  }
  #[inline]
  pub fn mobs_to_simplify_ai(&self) -> Option<flatbuffers::Vector<'a, u64>> {
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(MobProcessResult::VT_MOBS_TO_SIMPLIFY_AI, None) }
  }
}

impl flatbuffers::Verifiable for MobProcessResult<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("mobs_to_disable_ai", Self::VT_MOBS_TO_DISABLE_AI, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>("mobs_to_simplify_ai", Self::VT_MOBS_TO_SIMPLIFY_AI, false)?
     .finish();
    Ok(())
  }
}
pub struct MobProcessResultArgs<'a> {
    pub mobs_to_disable_ai: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
    pub mobs_to_simplify_ai: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for MobProcessResultArgs<'a> {
  #[inline]
  fn default() -> Self {
    MobProcessResultArgs {
      mobs_to_disable_ai: None,
      mobs_to_simplify_ai: None,
    }
  }
}

pub struct MobProcessResultBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MobProcessResultBuilder<'a, 'b> {
  #[inline]
  pub fn add_mobs_to_disable_ai(&mut self, mobs_to_disable_ai: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MobProcessResult::VT_MOBS_TO_DISABLE_AI, mobs_to_disable_ai);
  }
  #[inline]
  pub fn add_mobs_to_simplify_ai(&mut self, mobs_to_simplify_ai: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MobProcessResult::VT_MOBS_TO_SIMPLIFY_AI, mobs_to_simplify_ai);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MobProcessResultBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MobProcessResultBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MobProcessResult<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MobProcessResult<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MobProcessResult");
      ds.field("mobs_to_disable_ai", &self.mobs_to_disable_ai());
      ds.field("mobs_to_simplify_ai", &self.mobs_to_simplify_ai());
      ds.finish()
  }
}
pub enum AiConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct AiConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for AiConfig<'a> {
  type Inner = AiConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> AiConfig<'a> {
  pub const VT_PASSIVE_DISABLE_DISTANCE: flatbuffers::VOffsetT = 4;
  pub const VT_HOSTILE_SIMPLIFY_DISTANCE: flatbuffers::VOffsetT = 6;
  pub const VT_AI_TICK_RATE_FAR: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    AiConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args AiConfigArgs
  ) -> flatbuffers::WIPOffset<AiConfig<'bldr>> {
    let mut builder = AiConfigBuilder::new(_fbb);
    builder.add_ai_tick_rate_far(args.ai_tick_rate_far);
    builder.add_hostile_simplify_distance(args.hostile_simplify_distance);
    builder.add_passive_disable_distance(args.passive_disable_distance);
    builder.finish()
  }


  #[inline]
  pub fn passive_disable_distance(&self) -> f32 {
    unsafe { self._tab.get::<f32>(AiConfig::VT_PASSIVE_DISABLE_DISTANCE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn hostile_simplify_distance(&self) -> f32 {
    unsafe { self._tab.get::<f32>(AiConfig::VT_HOSTILE_SIMPLIFY_DISTANCE, Some(0.0)).unwrap() }
  }
  #[inline]
  pub fn ai_tick_rate_far(&self) -> f32 {
    unsafe { self._tab.get::<f32>(AiConfig::VT_AI_TICK_RATE_FAR, Some(0.0)).unwrap() }
  }
}

impl flatbuffers::Verifiable for AiConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("passive_disable_distance", Self::VT_PASSIVE_DISABLE_DISTANCE, false)?
     .visit_field::<f32>("hostile_simplify_distance", Self::VT_HOSTILE_SIMPLIFY_DISTANCE, false)?
     .visit_field::<f32>("ai_tick_rate_far", Self::VT_AI_TICK_RATE_FAR, false)?
     .finish();
    Ok(())
  }
}
pub struct AiConfigArgs {
    pub passive_disable_distance: f32,
    pub hostile_simplify_distance: f32,
    pub ai_tick_rate_far: f32,
}
impl<'a> Default for AiConfigArgs {
  #[inline]
  fn default() -> Self {
    AiConfigArgs {
      passive_disable_distance: 0.0,
      hostile_simplify_distance: 0.0,
      ai_tick_rate_far: 0.0,
    }
  }
}

pub struct AiConfigBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AiConfigBuilder<'a, 'b> {
  #[inline]
  pub fn add_passive_disable_distance(&mut self, passive_disable_distance: f32) {
    self.fbb_.push_slot::<f32>(AiConfig::VT_PASSIVE_DISABLE_DISTANCE, passive_disable_distance, 0.0);
  }
  #[inline]
  pub fn add_hostile_simplify_distance(&mut self, hostile_simplify_distance: f32) {
    self.fbb_.push_slot::<f32>(AiConfig::VT_HOSTILE_SIMPLIFY_DISTANCE, hostile_simplify_distance, 0.0);
  }
  #[inline]
  pub fn add_ai_tick_rate_far(&mut self, ai_tick_rate_far: f32) {
    self.fbb_.push_slot::<f32>(AiConfig::VT_AI_TICK_RATE_FAR, ai_tick_rate_far, 0.0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AiConfigBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AiConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<AiConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for AiConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("AiConfig");
      ds.field("passive_disable_distance", &self.passive_disable_distance());
      ds.field("hostile_simplify_distance", &self.hostile_simplify_distance());
      ds.field("ai_tick_rate_far", &self.ai_tick_rate_far());
      ds.finish()
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_mob_input<'a>(buf: &'a [u8]) -> MobInput<'a> {
  unsafe { flatbuffers::root_unchecked::<MobInput<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_mob_input<'a>(buf: &'a [u8]) -> MobInput<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<MobInput<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `MobInput`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mob_input_unchecked`.
pub fn root_as_mob_input(buf: &[u8]) -> Result<MobInput, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<MobInput>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `MobInput` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_mob_input_unchecked`.
pub fn size_prefixed_root_as_mob_input(buf: &[u8]) -> Result<MobInput, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<MobInput>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `MobInput` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mob_input_unchecked`.
pub fn root_as_mob_input_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MobInput<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<MobInput<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `MobInput` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_mob_input_unchecked`.
pub fn size_prefixed_root_as_mob_input_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<MobInput<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<MobInput<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a MobInput and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `MobInput`.
pub unsafe fn root_as_mob_input_unchecked(buf: &[u8]) -> MobInput {
  flatbuffers::root_unchecked::<MobInput>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed MobInput and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `MobInput`.
pub unsafe fn size_prefixed_root_as_mob_input_unchecked(buf: &[u8]) -> MobInput {
  flatbuffers::size_prefixed_root_unchecked::<MobInput>(buf)
}
#[inline]
pub fn finish_mob_input_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<MobInput<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_mob_input_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<MobInput<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod mob
}  // pub mod kneaf
